//      Redistribution and use in source and binary forms, with or without
//      modification, are permitted provided that the following conditions are
//      met:
//      
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//        copyright notice, this list of conditions and the following disclaimer
//        in the documentation and/or other materials provided with the
//        distribution.
//      * Neither the name of the  nor the names of its
//        contributors may be used to endorse or promote products derived from
//        this software without specific prior written permission.
//      
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#include "generic/ArrayResource.hpp"

namespace kiwi
{
namespace generic
{



template<typename T, unsigned int D>
ArrayReader<T,D>::ArrayReader(
	const core::Node::ReaderInputPort& port )
{
	ArrayResource<T,D>* node = 
		dynamic_cast< ArrayResource<T,D>* >( 
			port.connectedOutput()->subPort()->node() 
		);
	if(!node)
	{
		debug.error() << "ArrayReader<"
			<< types::str<T>() 
			<< ">::Constructor : "
			<< "enable to determine the Resource type" 
			<< endl();
	}
	_port = port.connectedOutput()->index();
	_data = node->getDataPointer(_port);
	_incs = node->increments(_port);
	_span = node->spanSize();
/*	unsigned csize = 1;
	for(unsigned i = 0; i < D; ++i) csize*=_span(i);
	_end = _data + csize;
*/ 
}



template<typename T, unsigned int D>
ArrayReader<T,D>::ArrayReader( const ArrayResource<T,D>& resource, portIndex_t portIndex )
{
	_port = portIndex;
	_data = resource.getDataPointer(_port);
	_incs = resource.increments(_port);
	_span = resource.spanSize();
}



template<typename T, unsigned int D>
T ArrayReader<T,D>::get(const Point<int,D>& coords) const
{
//	ScopedBlockMacro(__scop, "get" );
	unsigned index = 0;
	for(unsigned i = 0; i < D; ++i)
	{
		index += _incs(i)*coords(i);
	}
//	debug.print() << "index "  << index << endl();
	return _data[index];
}


template<typename T, unsigned int D>
T ArrayReader<T,D>::get(unsigned int i) const
{
	return _data[i];
}

template<typename T, unsigned int D>
ArrayConstIterator<T> ArrayReader<T,D>::getIterator() const
{
	unsigned size = 1;
	for(unsigned i = 0; i < D; ++i) size *= _span(i);
	return ArrayConstIterator<ValueType>(_data, _data+size*_incs(0)-1, _incs(0) ); 
}


} // namespace
} // namespace

