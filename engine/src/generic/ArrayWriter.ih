//      Redistribution and use in source and binary forms, with or without
//      modification, are permitted provided that the following conditions are
//      met:
//      
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//        copyright notice, this list of conditions and the following disclaimer
//        in the documentation and/or other materials provided with the
//        distribution.
//      * Neither the name of the  nor the names of its
//        contributors may be used to endorse or promote products derived from
//        this software without specific prior written permission.
//      
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


namespace kiwi
{
namespace generic
{




template<typename T, unsigned int D>
ArrayWriter<T,D>::ArrayWriter(
	const core::Resource::WriterInputPort& port
)
{
	ArrayContainer<T,D>* node = 
		dynamic_cast< ArrayContainer<T,D>* >( 
			port.connectedOutput()->subPort()->node()
		);
	if(!node)
	{
		debug.error() << "ArrayContainerWriter<"
			<<types::str<T>() 
			<< ">::Constructor : "
			<< "enable to determine the Resource type" 
			<< endl();
	}
	_port = port.connectedOutput()->index();
	_data = node->getDataPointer(_port);
	_incs = node->increments(_port);
	_span = node->spanSize();

}



template<typename T, unsigned int D>
T ArrayWriter<T,D>::get(const Point<int,D>& coords) const
{
	unsigned index = 0;
	for(unsigned i = 0; i < D; ++i)
		index += _incs(i)*coords(i);
		
	return _data[index];
}

template<typename T, unsigned int D>
void ArrayWriter<T,D>::set(const Point<int, D>& coords, ValueType value)
{
	unsigned index = 0;
	for(unsigned i = 0; i < D; ++i)
		index += _incs(i)*coords(i);
		
	_data[index] = value;
}

template<typename T, unsigned int D>
void ArrayWriter<T,D>::set(unsigned int i, ValueType value)
{
	_data[i] = value;
}
template<typename T, unsigned int D>
T ArrayWriter<T,D>::get(unsigned int i) const
{
	return _data[i];
}


} // namespace
} // namespace
