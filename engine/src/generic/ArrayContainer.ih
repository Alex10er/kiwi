//      Redistribution and use in source and binary forms, with or without
//      modification, are permitted provided that the following conditions are
//      met:
//      
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//        copyright notice, this list of conditions and the following disclaimer
//        in the documentation and/or other materials provided with the
//        distribution.
//      * Neither the name of the  nor the names of its
//        contributors may be used to endorse or promote products derived from
//        this software without specific prior written permission.
//      
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

namespace kiwi
{
namespace generic
{

template<typename T, unsigned int D>
ArrayContainer<T,D>::ArrayContainer(Coordinates size
	, unsigned char nbComponents
	, bool interleaved 
	, unsigned char nameHint)
:_interleaved(interleaved), _nbComponents(nbComponents), _nameHint(nameHint)
{
	_deleteDataDestructor = true;
	_spanSize = size;
	// compute the total size
	_totalSize = nbComponents;
	for(unsigned i = 0; i < D; ++i)	_totalSize*= size(i);
	debug.print() << "allocate " << _totalSize << endl();
	// allocate the data
	_data = new T[_totalSize];
	
	init();
}

template<typename T, unsigned int D>
ArrayContainer<T,D>::ArrayContainer(ValueType* dataPtr
	, Coordinates size
	, unsigned char nbComponents
	, bool interleaved
	, unsigned char nameHint)
:_interleaved(interleaved), _nbComponents(nbComponents )
{
	_deleteDataDestructor = false;
	_spanSize = size;
	// compute the total size
	_totalSize = nbComponents;
	for(unsigned i = 0; i < D; ++i)	_totalSize*= size(i);

	_data = dataPtr;
	
	init();
}


template<typename T, unsigned int D>
void ArrayContainer<T,D>::init()
{
// disable the event so that layoutChanged() is not called from
	// within the constructor
	setLayoutEventEnabled(false);
	// "compute" the runtime type name of this class in function of
	// the template parameters
	kiwi::string sType("array"
			+ boost::lexical_cast<kiwi::string>(D)+"d_"
			+ types::str<T>() );
			
	for(unsigned i = 0; i < _nbComponents; ++i)
	{
		addWriterOutputPort( sType );
		addReaderOutputPort( sType );
	}
	setLayoutEventEnabled(true);
}


template<typename T, unsigned int D>
ArrayContainer<T,D>::~ArrayContainer()
{
	if(_deleteDataDestructor) delete[] _data;
	
}


template<typename T, unsigned int D>
kiwi:: string 
ArrayContainer<T,D>::readerOutputPortName(portIndex_t index)
{
	return portName(index, _nameHint, READER_OUT);
}


template<typename T, unsigned int D>
kiwi:: string 
ArrayContainer<T,D>::writerOutputPortName(portIndex_t index)
{
	return portName(index, _nameHint, WRITER_OUT);
}

template<typename T, unsigned int D>
kiwi::string ArrayContainer<T,D>::portName(portIndex_t index
	, unsigned char nameHint
	, unsigned char portType) const
{
	switch(nameHint)
	{
		case XYZ :
		switch(index)
		{
			case 0 : { return "x"; }
			case 1 : { return "y"; }
			case 2 : { return "z"; }
			case 3 : { return "w"; }
			default : { return "#"; }
		}
		case RVBA :
		switch(index)
		{
			case 0 : { return "r"; }
			case 1 : { return "v"; }
			case 2 : { return "b"; }
			case 3 : { return "a"; }
			default : { return "#"; }
		}
		case CMJN :
		switch(index)
		{
			case 0 : { return "c"; }
			case 1 : { return "m"; }
			case 2 : { return "j"; }
			case 3 : { return "n"; }
			default : { return "#"; }
		}
		case ABCD : {
			char a = 97+index;
			return kiwi::string( &a );
		}
		case MONO : {
			if(portType == READER_OUT) return "read";
			else return "write";
		}
		default : return boost::lexical_cast<kiwi::string>(index);
	}
}	


template<typename T, unsigned int D>
Point<unsigned int, D+1>
ArrayContainer<T,D>::increments(portIndex_t index) const
{
	
	IncsType incs;
	if(_interleaved) incs(0) = _nbComponents;
	else incs(0) = 1;
	unsigned temp = incs(0);
	for(unsigned i = 0; i < D; ++i)
	{
		temp *= _spanSize(i);
		incs(i+1) = temp;
	}
	return incs;
}

template<typename T, unsigned int D>
ArrayIterator<T> ArrayContainer<T,D>::getBasicIterator() const
{ 
	return ArrayIterator<ValueType>( _data, _data + _totalSize-1, 1 ); 
}
	


template<typename T, unsigned int D>
T* const ArrayContainer<T,D>::getDataPointer(portIndex_t index) const
{
ScopedBlockMacro(__scop, "ArrayConstIterator::getDataPointer")
	if(_interleaved)
		return _data + index;
	else
	{
		return _data + index * oneBufferSize();
	}
}


template<typename T, unsigned int D>
unsigned int ArrayContainer<T,D>::oneBufferSize() const
{
	unsigned int oneBuffer = 1;
	for(unsigned i = 0; i < D; ++i) oneBuffer *= _spanSize(i);
	return oneBuffer;
}

template<typename T, unsigned int D>
void ArrayContainer<T,D>::printState()
{
ScopedBlockMacro(__scop, kiwi::string("ArrayContainer<")
	+  types::str<T>() 
	+ "," + boost::lexical_cast<string>( D )
	+ ">::printState" )
	
	ArrayIterator<ValueType> it = getBasicIterator();
	
	do{		
		debug.print() << *it;
	}while ( it.onIteration() );

	debug.endl();
	debug.print() << _totalSize << " elements" << endl(); 
}



} // namespace
} // namespace
