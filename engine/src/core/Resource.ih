//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{
	debug.print() << "Resource::constructor"<<endl();
	_layoutEvtEnabled = true;
}

Resource::~Resource()
{
	debug.print() << "Resource::destructor"<<endl();
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}

}


void Resource::addReaderInputPort(const string& type)
{
	_readerInputs.push_back( new InputPort<Reader>(this, type) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::addReaderOutputPort(const string& type)
{
	_readerOutputs.push_back( new OutputPort<Reader>(this, type) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::addWriterInputPort(const string& type)
{
	_writerInputs.push_back( new InputPort<Writer>(this, type) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::addWriterOutputPort(const string& type)
{
	_writerOutputs.push_back( new OutputPort<Writer>(this, type) );
	if( isLayoutEventEnabled() ) layoutChanged();
}


void 
Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

portIndex_t 
Resource::indexOf(const ReaderInputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _readerInputs.size(); ++i)
		if(_readerInputs[i] == &port)
			return i;
			
	DEBUG_ONLY(//debug	
	debug.error() 
		<< "Resource::indexOf( ReaderInputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t 
Resource::indexOf(const WriterInputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _writerInputs.size(); ++i)
		if(_writerInputs[i] == &port)
			return i;
	DEBUG_ONLY(	
	debug.error() 
		<< "Resource::indexOf( WriterInputPort& ) Error : unknown port !" 
		<< endl(); 
	)
	//default value
	return 0;
}

portIndex_t 
Resource::indexOf(const ReaderOutputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _readerOutputs.size(); ++i)
		if(_readerOutputs[i] == &port)
			return i;
			
	DEBUG_ONLY(//debug	
	debug.error() 
		<< "Resource::indexOf( ReaderOutputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t 
Resource::indexOf(const WriterOutputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _writerOutputs.size(); ++i)
		if( _writerOutputs[i] == &port )
			return i;
			
	DEBUG_ONLY(
	debug.error() 
		<< "Resource::indexOf( WriterOutputPort& ) Error : unknown port !" 
		<< endl();
	)//DEBUG_ONLY
		
	//default value
	return 0;	
}

// ------------------------------------------------------ port rebinding

inline void 
Resource::bindPort(ReaderOutputPort& myPort, ReaderOutputPort& toBind)
{ 
	myPort.bind(toBind); 
}

inline void 
Resource::bindPort(WriterOutputPort& myPort, WriterOutputPort& toBind)
{ 
	myPort.bind(toBind);
}

inline void 
Resource::bindPort(ReaderInputPort& myPort, ReaderInputPort& toBind)
{ 
	myPort.bind(toBind); 
}

inline void 
Resource::bindPort(WriterInputPort& myPort, WriterInputPort& toBind)
{ 
	myPort.bind(toBind); 
}


// ---------------------------------------------------------- port names


kiwi::string 
Resource::readerInputPortName(portIndex_t index) 
{
	return kiwi::string("#");
}

kiwi::string 
Resource::readerOutputPortName(portIndex_t index)
{
	return kiwi::string("#");
}

kiwi::string 
Resource::writerInputPortName(portIndex_t index)
{
	return kiwi::string("#");
}

kiwi::string 
Resource::writerOutputPortName(portIndex_t index)
{
	return kiwi::string("#");
}





// ----------------------------------------------------------- Operators

template <typename SlotType>
bool 
operator >> (
	Resource::OutputPort<SlotType>& output
	, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
