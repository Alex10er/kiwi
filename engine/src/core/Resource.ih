//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{
	debug.print() << "Resource::constructor"<<endl();
	_layoutEvtEnabled = true;
}

Resource::~Resource()
{
	debug.print() << "Resource::destructor"<<endl();
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}

}


void Resource::addReaderInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::addReaderOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::addWriterInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::addWriterOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();

}




void Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

portIndex_t Resource::indexOf(const ReaderInputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _readerInputs.size(); ++i)
		if(_readerInputs[i] == &port)
			return i;
			
	__(//debug	
	debug.error() 
		<< "Resource::indexOf( ReaderInputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t Resource::indexOf(const WriterInputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _writerInputs.size(); ++i)
		if(_writerInputs[i] == &port)
			return i;
	__(	
	debug.error() 
		<< "Resource::indexOf( WriterInputPort& ) Error : unknown port !" 
		<< endl(); 
	)
	//default value
	return 0;	
}

portIndex_t Resource::indexOf(const ReaderOutputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _readerOutputs.size(); ++i)
		if(_readerOutputs[i] == &port)
			return i;
			
	__(//debug	
	debug.error() 
		<< "Resource::indexOf( ReaderOutputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t Resource::indexOf(const WriterOutputPort& port) const
{
ScopedBlockMacro(__scop, "Resource::indexOf");
	for(unsigned i = 0; i < _writerOutputs.size(); ++i)
		if( _writerOutputs[i] == &port )
			return i;
			
	__(//debug	
	debug.error() 
		<< "Resource::indexOf( WriterOutputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

kiwi::string Resource::readerInputPortName(portIndex_t index) 
{
	return kiwi::string("");
}

kiwi::string Resource::readerOutputPortName(portIndex_t index)
{
	return kiwi::string("");
}

kiwi::string Resource::writerInputPortName(portIndex_t index)
{
	return kiwi::string("");
}

kiwi::string Resource::writerOutputPortName(portIndex_t index)
{
	return kiwi::string("");
}

// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Port classes -------------------
// -----------------------------------------------------------------------------------------

// ----------------------------------------------------------- InputPort
template <typename SlotType>
Resource::InputPort<SlotType>::InputPort(
	Resource* myResource
//	, portIndex_t myIndex // TODO: unused param
	, const string& type
	, const string& name )
:  _type(type), _name(name)
, _connectedResource(0), _enabled(true), _subPort(0), _resource(myResource)
{
	
}


template <typename SlotType>
void Resource::InputPort<SlotType>::connect(OutputPort<SlotType>& outputPort, bool isMetaPort)
{
ScopedBlockMacro(__sccop, "Resource::InputPort<SlotType>::connect" );
	if( !isEnabled() )
	{
		debug.error() << "InputPort::connect() : input port disabled" << endl();
		return;
	}
	if( !outputPort.isEnabled() )
	{
		debug.error() << "InputPort::connect() : output port disabled" << endl();
		return;
	}
	// if it is the subPort
	
		if(isCompatible(outputPort) )
		{
			if( isConnected() ) disconnect();
			_connectedResource = &outputPort;
			if( isMetaPort ) outputPort._connections.push_back(this);
			if( _subPort != 0 )	_subPort->connect(outputPort, false);
			if( _resource->isLayoutEventEnabled() ) 
					_resource->layoutChanged();
		}
		else
		{
			debug.error() << "InputPort::connect() : uncompatible ports - connection failed" << endl();
			debug.error() << outputPort.type() << " >> " << type() << endl();
			return;
		}
	
}

template <typename SlotType>
void Resource::InputPort<SlotType>::disconnect()
{
ScopedBlockMacro(scp_block,"Resource::InputPort<SlotType>::disconnect");
	if(_subPort != 0) _subPort->disconnect();
	if(!isConnected() ) return;
	for(typename OutputPort<SlotType>::connectionList::iterator it
		= _connectedResource->_connections.begin(); it!= _connectedResource->_connections.end(); ++it)
	{
		if(*it == this)
		{
			_connectedResource->_connections.erase(it);
			break;
		}
	}
	_connectedResource= 0;
}


template <typename SlotType>
void Resource::InputPort<SlotType>::bind(/*const*/ InputPort<SlotType>& port)
{
__(	debug.print() << "input port rebinding" << endl();  )
	_type = port._type;
	_subPort = &port;
	// note that if the binded Resource is deleted, trying to acces
	// this port might cause a segfault
}


template<>
//template <typename SlotType>
string Resource::InputPort<Reader>::name()
{
	return _resource->readerInputPortName(_resource->indexOf(*this));
}
template<>
//template <typename SlotType>
string Resource::InputPort<Writer>::name()
{
	return _resource->readerInputPortName(_resource->indexOf(*this));
}

// ---------------------------------------------------------- OutputPort

template <typename SlotType>
Resource::OutputPort<SlotType>::OutputPort(
	Resource* myResource
	, const string& type
	, const string& name )	
:  _type(type)
	, _name(name)
	, _enabled(true)
	, _resource(myResource)
	, _subPort(0)
{
	// nothing to do
}

template <typename SlotType>
Resource::OutputPort<SlotType>* 
Resource::OutputPort<SlotType>::subPort() //const 
{
	// if there's port rebinding, _subPort != 0 
	// call the _subPort's method
	if(_subPort) return _subPort->subPort();
	// if this is the "subport" return a pointer to self
	else return this;
} 

template <typename SlotType>
void Resource::OutputPort<SlotType>::disconnect()
{
	typename std::list<Resource::InputPort<SlotType>*>::iterator it;
	for(it = _connections.begin(); it!= _connections.end(); ++it)
	{
		(*it)->disconnect();
	}
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::bind(OutputPort<SlotType>& port)
{
	debug.print() << "port rebinding" << endl();
	
	_subPort = &port;

	_type = port._type;
	// note that if the binded Resource is deleted, trying to acces
	// this port might cause a segfault
}


template<>
string Resource::OutputPort<Reader>::name()
{
	return _resource->readerOutputPortName( _resource->indexOf(*this) );
}

template<>
string Resource::OutputPort<Writer>::name()
{
	return _resource->readerOutputPortName(	_resource->indexOf(*this) );
}

template <typename SlotType>
portIndex_t Resource::OutputPort<SlotType>::index() const 
{
	return _resource->indexOf(*this);
	//return subPort()->index();
}

template <typename SlotType>
Resource* Resource::OutputPort<SlotType>::resource() const 
{
	return _resource;
}

template <typename SlotType>
string Resource::OutputPort<SlotType>::type() 
{ 
	return _type; 
}

template <typename SlotType>
bool Resource::OutputPort<SlotType>::isCompatible(OutputPort<SlotType>& output)	
{
	return ( type().find(output.type())!= string::npos 
	|| type().find("any")!= string::npos ); 
}

template <typename SlotType>
bool Resource::OutputPort<SlotType>::isConnected() const 
{ 
	return (_connections.size() != 0); 
}

template <typename SlotType>
bool Resource::OutputPort<SlotType>::isEnabled() const 
{ 
	return _enabled; 
}

template <typename SlotType>
typename Resource::OutputPort<SlotType>::connectionList 
Resource::OutputPort<SlotType>::connections() const 
{ 
	return _connections; 
}

template <typename SlotType>
void Resource::OutputPort<SlotType>::setName(const string& name)
{
	_name = name;
}

template <typename SlotType>
void Resource::OutputPort<SlotType>::setType(const string& type)
{
	_type = type;
}

template <typename SlotType>
void Resource::OutputPort<SlotType>::setEnabled(bool status) 
{
	_enabled = status;
}

// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------



// ----------------------------------------------------------- Operators

template <typename SlotType>
bool operator >> (Resource::OutputPort<SlotType>& output, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
