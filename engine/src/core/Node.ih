//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Node -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Node::Node()
{
	debug.print() << "Node::constructor"<<endl();
	_layoutEvtEnabled = true;
}

Node::~Node()
{
	debug.print() << "Node::destructor"<<endl();
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}

}


void Node::addReaderInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Node::addReaderOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Node::addWriterInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Node::addWriterOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
//	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();

}


void 
Node::removeReaderInputPort()
{
	_readerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Node::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Node::removeWriterInputPort()
{
	_writerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void 
Node::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

portIndex_t 
Node::indexOf(const ReaderInputPort& port) const
{
ScopedBlockMacro(__scop, "Node::indexOf");
	for(unsigned i = 0; i < _readerInputs.size(); ++i)
		if(_readerInputs[i] == &port)
			return i;
			
	DEBUG_ONLY(//debug	
	debug.error() 
		<< "Node::indexOf( ReaderInputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t 
Node::indexOf(const WriterInputPort& port) const
{
ScopedBlockMacro(__scop, "Node::indexOf");
	for(unsigned i = 0; i < _writerInputs.size(); ++i)
		if(_writerInputs[i] == &port)
			return i;
	DEBUG_ONLY(	
	debug.error() 
		<< "Node::indexOf( WriterInputPort& ) Error : unknown port !" 
		<< endl(); 
	)
	//default value
	return 0;
}

portIndex_t 
Node::indexOf(const ReaderOutputPort& port) const
{
ScopedBlockMacro(__scop, "Node::indexOf");
	for(unsigned i = 0; i < _readerOutputs.size(); ++i)
		if(_readerOutputs[i] == &port)
			return i;
			
	DEBUG_ONLY(//debug	
	debug.error() 
		<< "Node::indexOf( ReaderOutputPort& ) Error : unknown port !" 
		<< endl();
	)//debug
		
	//default value
	return 0;	
}

portIndex_t 
Node::indexOf(const WriterOutputPort& port) const
{
ScopedBlockMacro(__scop, "Node::indexOf");
	for(unsigned i = 0; i < _writerOutputs.size(); ++i)
		if( _writerOutputs[i] == &port )
			return i;
			
	DEBUG_ONLY(
	debug.error() 
		<< "Node::indexOf( WriterOutputPort& ) Error : unknown port !" 
		<< endl();
	)//DEBUG_ONLY
		
	//default value
	return 0;	
}

// ------------------------------------------------------ port rebinding

inline void 
Node::bindPort(ReaderOutputPort& myPort, ReaderOutputPort& toBind)
{ 
	myPort.bind(toBind); 
}

inline void 
Node::bindPort(WriterOutputPort& myPort, WriterOutputPort& toBind)
{ 
	myPort.bind(toBind);
}

inline void 
Node::bindPort(ReaderInputPort& myPort, ReaderInputPort& toBind)
{ 
	myPort.bind(toBind); 
}

inline void 
Node::bindPort(WriterInputPort& myPort, WriterInputPort& toBind)
{ 
	myPort.bind(toBind); 
}


// ---------------------------------------------------------- port names


kiwi::string 
Node::readerInputPortName(portIndex_t index) 
{
	return kiwi::string("");
}

kiwi::string 
Node::readerOutputPortName(portIndex_t index)
{
	return kiwi::string("");
}

kiwi::string 
Node::writerInputPortName(portIndex_t index)
{
	return kiwi::string("");
}

kiwi::string 
Node::writerOutputPortName(portIndex_t index)
{
	return kiwi::string("");
}





// ----------------------------------------------------------- Operators

template <typename SlotType>
bool 
operator >> (
	Node::OutputPort<SlotType>& output
	, Node::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
