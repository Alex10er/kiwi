// Copyright (c) 2010 Nicolas Silva
// All rights reserved.
//      Redistribution and use in source and binary forms, with or without
//      modification, are permitted provided that the following conditions are
//      met:
//      
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//        copyright notice, this list of conditions and the following disclaimer
//        in the documentation and/or other materials provided with the
//        distribution.
//      * Neither the name of the  nor the names of its
//        contributors may be used to endorse or promote products derived from
//        this software without specific prior written permission.
//      
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#include "kiwi/core/Ports.hpp"

namespace kiwi
{
namespace generic
{




template<typename T, unsigned int D>
ArrayWriter<T,D>::ArrayWriter(
	const core::WriterInputPort& port
)
{
	AbstractArrayContainer<T,D>* node = 
		dynamic_cast< AbstractArrayContainer<T,D>* >( 
			port.connectedOutput()->data()
		);
	if(!node)
	{
		Debug::error() << "ArrayWriter<"
			<<types::str<T>() 
			<< ">::Constructor : "
			<< "enable to determine the Container type" 
			<< endl();
	}
	_port = port.connectedOutput()->index();
	_data = node->getDataPointer(_port);
	_incs = node->increments(_port);
	_span = node->spanSize();

}




template<typename T, unsigned int D>
ArrayWriter<T,D>::ArrayWriter( 
	const AbstractArrayContainer<T,D>& resource
	, portIndex_t portIndex )
{
	_port = portIndex;
	_data = resource.getDataPointer(_port);
	_incs = resource.increments(_port);
	_span = resource.spanSize();
}



template<typename T, unsigned int D>
T 
ArrayWriter<T,D>::get(const Point<int,D>& coords) const
{
	unsigned index = 0;
	for(unsigned i = 0; i < D; ++i)
		index += _incs(i)*coords(i);
		
	return _data[index];
}

template<typename T, unsigned int D>
void 
ArrayWriter<T,D>::set(const Point<int, D>& coords, ValueType value)
{
	unsigned index = 0;
	for(unsigned i = 0; i < D; ++i)
		index += _incs(i)*coords(i);
		
	_data[index] = value;
}

template<typename T, unsigned int D>
void 
ArrayWriter<T,D>::set(unsigned int i, ValueType value)
{
	_data[i] = value;
}


template<typename T, unsigned int D>
T 
ArrayWriter<T,D>::get(unsigned int i) const
{
	return _data[i];
}


template<typename T, unsigned int D>
uint32_t
ArrayWriter<T,D>::nbScalarElements() const
{
	uint32_t res = _span(0);
	for(unsigned i = 1; i < D; ++i)
		res *= _span(i);
	return res;
}


template<typename T, unsigned int D>
ArrayIterator<T> 
ArrayWriter<T,D>::getIterator() const
{
	unsigned size = 1;
	for(unsigned i = 0; i < D; ++i) size *= _span(i);
	return ArrayIterator<ValueType>(
			_data
			, _data + (size-1) * _incs(0)
			, _incs(0) ); 
}


template<typename T, unsigned int D>
ArrayIterator<T> 
ArrayWriter<T,D>::getSpanIterator(
		const Point<uint32_t, D>& origin
		, uint8_t dim  
		) const
{
	uint32_t offset = 0;

	
	for(unsigned i = 0; i < D; ++i)
	{
		offset += _incs(i)*origin(i);
	}
	
	uint32_t diff = _span(dim) - origin(dim) -1;
	

	return ArrayIterator<ValueType>(
			_data+offset
			, _data+offset+diff*_incs(dim)
			, _incs(dim) ); 
}


template<typename T, unsigned int D>
ArrayIterator<T> 
ArrayWriter<T,D>::getSpanIterator(
		const ArrayIterator<T>& origin
		, uint8_t dim  
		) const
{
	return getSpanIterator(positionOf(origin), dim);
}


template<typename T, unsigned int D>
Point<uint32_t, D> 
ArrayWriter<T,D>::positionOf(const ArrayIterator<T>& it) const
{
	Point<uint32_t, D> result;
	T* ptr = it.ptr();
	kiwi::uint32_t dist = ptr - _data;

	for(int i = 0; i<D; ++i )
	{
		result[i] = (dist % _incs(i+1))/_incs(i);
		dist -= result[i];
	}
//	Debug::print()<<"posOf "<< result[0] << " " << result[1] << endl();
	return result;
}


} // namespace
} // namespace
