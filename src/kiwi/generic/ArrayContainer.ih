// Copyright (c) 2010 Nicolas Silva
// All rights reserved.
//      Redistribution and use in source and binary forms, with or without
//      modification, are permitted provided that the following conditions are
//      met:
//      
//      * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//      * Redistributions in binary form must reproduce the above
//        copyright notice, this list of conditions and the following disclaimer
//        in the documentation and/or other materials provided with the
//        distribution.
//      * Neither the name of the  nor the names of its
//        contributors may be used to endorse or promote products derived from
//        this software without specific prior written permission.
//      
//      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//      "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

namespace kiwi
{
namespace generic
{

template<typename T, unsigned int D>
ArrayContainer<T,D>::ArrayContainer(Coordinates size
	, unsigned char nbComponents
	, bool interleaved 
	, unsigned char nameHint)
:_interleaved(interleaved), _nbComponents(nbComponents)
{
	_deleteDataDestructor = true;
	_spanSize = size;
	// compute the total size
	_totalSize = nbComponents;
	for(unsigned i = 0; i < D; ++i)	_totalSize*= size(i);
	Debug::print() << "allocate " << _totalSize << endl();
	// allocate the data
	_data = new T[_totalSize];
	
	init(nameHint);
}

template<typename T, unsigned int D>
ArrayContainer<T,D>::ArrayContainer(ValueType* dataPtr
	, Coordinates size
	, unsigned char nbComponents
	, bool interleaved
	, unsigned char nameHint)
:_interleaved(interleaved), _nbComponents(nbComponents )
{
	_deleteDataDestructor = false;
	_spanSize = size;
	// compute the total size
	_totalSize = nbComponents;
	for(unsigned i = 0; i < D; ++i)	_totalSize*= size(i);

	_data = dataPtr;
	
	init(nameHint);
}


template<typename T, unsigned int D>
void ArrayContainer<T,D>::init(unsigned char nameHint)
{		
	for(unsigned i = 0; i < _nbComponents; ++i)
	{
		Node::addWriterOutputPort();
		Node::addReaderOutputPort();
	}
}


template<typename T, unsigned int D>
ArrayContainer<T,D>::~ArrayContainer()
{
	if(_deleteDataDestructor) delete[] _data;
}


template<typename T, unsigned int D>
kiwi::string ArrayContainer<T,D>::portName(portIndex_t index
	, unsigned char nameHint
	, unsigned char portType) const
{
	switch(nameHint)
	{
		case XYZ :
		switch(index)
		{
			case 0 : { return "x"; }
			case 1 : { return "y"; }
			case 2 : { return "z"; }
			case 3 : { return "w"; }
			default : { return "#"; }
		}
		case RGBA :
		switch(index)
		{
			case 0 : { return "r"; }
			case 1 : { return "g"; }
			case 2 : { return "b"; }
			case 3 : { return "a"; }
			default : { return "#"; }
		}
		case CMYK :
		switch(index)
		{
			case 0 : { return "c"; }
			case 1 : { return "m"; }
			case 2 : { return "y"; }
			case 3 : { return "k"; }
			default : { return "#"; }
		}
		case ABCD : {
			char a = 97+index;
			return kiwi::string( &a );
		}
		case MONO : {
			if(portType == READER_OUT) return "read";
			else return "write";
		}
		default : return boost::lexical_cast<kiwi::string>(index);
	}
}	


template<typename T, unsigned int D>
Point<unsigned int, D+1>
ArrayContainer<T,D>::increments(portIndex_t index) const
{
	
	IncsType incs;
	if(_interleaved) incs(0) = _nbComponents;
	else incs(0) = 1;
	unsigned temp = incs(0);
	for(unsigned i = 0; i < D; ++i)
	{
		temp *= _spanSize(i);
		incs(i+1) = temp;
	}
	return incs;
}

template<typename T, unsigned int D>
ArrayIterator<T> ArrayContainer<T,D>::getBasicIterator() const
{ 
	return ArrayIterator<ValueType>( _data, _data + _totalSize-1, 1 ); 
}
	


template<typename T, unsigned int D>
T* const ArrayContainer<T,D>::getDataPointer(portIndex_t index) const
{
ScopedBlockMacro(__scop, "ArrayConstIterator::getDataPointer")
	if(_interleaved)
		return _data + index;
	else
	{
		return _data + index * oneBufferSize();
	}
}


template<typename T, unsigned int D>
unsigned int ArrayContainer<T,D>::oneBufferSize() const
{
	unsigned int oneBuffer = 1;
	for(unsigned i = 0; i < D; ++i) oneBuffer *= _spanSize(i);
	return oneBuffer;
}

template<typename T, unsigned int D>
void ArrayContainer<T,D>::printState()
{
ScopedBlockMacro(__scop, kiwi::string("ArrayContainer<")
	+  types::str<T>() 
	+ "," + boost::lexical_cast<string>( D )
	+ ">::printState" )
	
	ArrayIterator<ValueType> it = getBasicIterator();
	
	do{		
		Debug::print() << *it;
	}while ( it.onIteration() );

	Debug::endl();
	Debug::print() << _totalSize << " elements" << endl(); 
}


template<typename T, unsigned int D>
void ArrayContainer<T,D>::registerToFactory(kiwi::core::NodeFactory& factory, const kiwi::string& filterId)
{
	kiwi::string tags("#Container#array");
	kiwi::string name("ArrayContainer<");
	
	tags += boost::lexical_cast<kiwi::string>(D) + types::str<ValueType>();
	
	name += boost::lexical_cast<kiwi::string>(D) + "," + types::str<ValueType>() + ">";
	
	factory.registerNode( filterId
			, kiwi::core::Descriptor<kiwi::core::Container>(
				name
				, newArrayContainer
				, tags )
		);
}


} // namespace
} // namespace
