//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{
	debug.print() << "Resource::constructor"<<endl();
}

Resource::~Resource()
{
	debug.print() << "Resource::destructor"<<endl();
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}

}


void Resource::addReaderInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, index, type, name) );
	layoutChanged();
}
void Resource::addReaderOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, index, type, name) );
	layoutChanged();
}

void Resource::addWriterInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, index, type, name) );
	layoutChanged();
}
void Resource::addWriterOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, index, type, name) );
	layoutChanged();

}

/*			---- TODO ----
void Resource::addReaderOutputPortFromResource(const ReaderOutputPort& port)
{
	port.setSecondaryResource(this);
	_writerOutputs.push_back( port );
	layoutChanged();
}
*/

void Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
	layoutChanged();
}
void Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
	layoutChanged();
}

void Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
	layoutChanged();
}
void Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
	layoutChanged();
}

// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Port classes -------------------
// -----------------------------------------------------------------------------------------

// ----------------------------------------------------------- InputPort
template <typename SlotType>
Resource::InputPort<SlotType>::InputPort(
	Resource* myResource
	, portIndex_t myIndex
	, const string& type
	, const string& name )
: _myResource(myResource), _myIndex(myIndex), _type(type), _name(name)
, _connectedResource(0)
{
}


template <typename SlotType>
void Resource::InputPort<SlotType>::connect(OutputPort<SlotType>& outputPort)
{
debug.beginBlock( "esource::InputPort<SlotType>::connect" );
	if(isCompatible(outputPort) )
	{
	_connectedResource = &outputPort;
	outputPort._connections.push_back(this);
	}
	else
	{
		debug.error() << "InputPort::connect() : uncompatible ports - connection failed" << endl();
		debug.error() << outputPort.getType() << " >> " << getType() << endl();
	}
debug.endBlock();
}

template <typename SlotType>
void Resource::InputPort<SlotType>::disconnect()
{
	debug.beginBlock("Resource::InputPort<SlotType>::disconnect");
	for(typename OutputPort<SlotType>::connectionList::iterator it
		= _connectedResource->_connections.begin(); it!= _connectedResource->_connections.end(); ++it)
	{
		if(*it == this)
		{
			_connectedResource->_connections.erase(it);
			break;
		}
	}
	_connectedResource= 0;
	debug.endBlock();
}


// ---------------------------------------------------------- OutputPort

template <typename SlotType>
Resource::OutputPort<SlotType>::OutputPort(
	Resource* myResource
	, portIndex_t myIndex
	, const string& type
	, const string& name )
: _myResource(myResource), _myIndex(myIndex), _type(type), _name(name)
{
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::disconnect()
{
	typename std::list<Resource::InputPort<SlotType>*>::iterator it;
	for(it = _connections.begin(); it!= _connections.end(); ++it)
	{
		it->disconnect();
	}
}





// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------



// ----------------------------------------------------------- Operators

template <typename SlotType>
bool operator >> (Resource::OutputPort<SlotType>& output, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
