//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{

}

Resource::~Resource()
{
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}
}


void Resource::addReaderInputPort(const string& name)
{
//debug.beginBlock("addReaderInputPort("+name+")");
	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, index, name) );
//debug.endBlock();
}
void Resource::addReaderOutputPort(const string& name)
{
//debug.beginBlock("addReaderOutputPort("+name+")");
	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, index, name) );
//debug.endBlock();
}

void Resource::addWriterInputPort(const string& name)
{
//debug.beginBlock("addWriterInputPort("+name+")");
	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, index, name) );
//debug.endBlock();
}
void Resource::addWriterOutputPort(const string& name)
{
//debug.beginBlock("addWriterOutputPort("+name+")");
	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, index, name) );
//debug.endBlock();
}


void Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
}
void Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
}

void Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
}
void Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
}

// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Port classes -------------------
// -----------------------------------------------------------------------------------------

// ----------------------------------------------------------- InputPort
template <typename SlotType>
Resource::InputPort<SlotType>::InputPort(Resource* myResource, portIndex_t myPort, const string& name)
{
	_connectedResource = 0;
	_myResource = myResource;
	_myIndex = myPort;
	_name = name;
}


template <typename SlotType>
void Resource::InputPort<SlotType>::connect(OutputPort<SlotType>& outputPort)
{
debug.beginBlock( "esource::InputPort<SlotType>::connect" );
	_connectedResource = &outputPort;
	outputPort._connections.push_back(this);
debug.endBlock();
}

template <typename SlotType>
void Resource::InputPort<SlotType>::disconnect()
{
	debug.beginBlock("Resource::InputPort<SlotType>::disconnect");
	for(typename OutputPort<SlotType>::connectionList::iterator it
		= _connectedResource->_connections.begin(); it!= _connectedResource->_connections.end(); ++it)
	{
		if(*it == this)
		{
			_connectedResource->_connections.erase(it);
			break;
		}
	}
	_connectedResource= 0;
	debug.endBlock();
}


// ---------------------------------------------------------- OutputPort

template <typename SlotType>
Resource::OutputPort<SlotType>::OutputPort(Resource* myResource, portIndex_t myPort, const string& name)
{
	_myResource = myResource;
	_myIndex = myPort;
	_name = name;
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::disconnect()
{
	typename std::list<Resource::InputPort<SlotType>*>::iterator it;
	for(it = _connections.begin(); it!= _connections.end(); ++it)
	{
		it->disconnect();
	}
}

/*
template <>
bool Resource::InputPort<Reader>::isCompatible(Resource::OutputPort<Reader>& output)
{
	Reader* theReader = output.resource()->newReader(output.index());
	bool result = _myResource->isReaderCompatible(_myIndex, theReader );
	delete theReader;
	return result;
}

template <>
bool Resource::InputPort<Writer>::isCompatible(Resource::OutputPort<Writer>& output)
{
	Writer* theWriter = output.resource()->newWriter(output.index());
	bool result = _myResource->isWriterCompatible(_myIndex, theWriter );
	delete theWriter;
	return result;
}

*/




// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------



// ----------------------------------------------------------- Operators

template <typename SlotType>
bool operator >> (Resource::OutputPort<SlotType>& output, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
