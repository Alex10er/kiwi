//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{
	debug.print() << "Resource::constructor"<<endl();
	_layoutEvtEnabled = true;
}

Resource::~Resource()
{
	debug.print() << "Resource::destructor"<<endl();
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}

}


void Resource::addReaderInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, index, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::addReaderOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, index, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::addWriterInputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, index, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::addWriterOutputPort(const string& type, const string& name)
{
//ScopedBlockMacro(scop_b,"addWriterOutputPort("+name+")");
	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, index, type, name) );
	if( isLayoutEventEnabled() ) layoutChanged();

}




void Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

void Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}
void Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
	if( isLayoutEventEnabled() ) layoutChanged();
}

// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Port classes -------------------
// -----------------------------------------------------------------------------------------

// ----------------------------------------------------------- InputPort
template <typename SlotType>
Resource::InputPort<SlotType>::InputPort(
	Resource* myResource
	, portIndex_t myIndex
	, const string& type
	, const string& name )
:  _type(type), _name(name), _connectedResource(0), _enabled(true)
{
	_metaResource.resource = myResource;
	_metaResource.index = myIndex;
	_subResource.resource = myResource;
	_subResource.index = myIndex;
}


template <typename SlotType>
void Resource::InputPort<SlotType>::connect(OutputPort<SlotType>& outputPort)
{
ScopedBlockMacro(__sccop, "Resource::InputPort<SlotType>::connect" );
	if( !isEnabled() )
	{
		debug.error() << "InputPort::connect() : input port disabled" << endl();
		return;
	}
	if( !outputPort.isEnabled() )
	{
		debug.error() << "InputPort::connect() : output port disabled" << endl();
		return;
	}
	if(isCompatible(outputPort) )
	{
		if( isConnected() ) disconnect();
		_connectedResource = &outputPort;
		outputPort._connections.push_back(this);
		if( _metaResource.resource->isLayoutEventEnabled() ) 
			_metaResource.resource->layoutChanged();
	}
	else
	{
		debug.error() << "InputPort::connect() : uncompatible ports - connection failed" << endl();
		debug.error() << outputPort.getType() << " >> " << getType() << endl();
		return;
	}

}

template <typename SlotType>
void Resource::InputPort<SlotType>::disconnect()
{
ScopedBlockMacro(scp_block,"Resource::InputPort<SlotType>::disconnect");
	if(!isConnected() ) return;
	for(typename OutputPort<SlotType>::connectionList::iterator it
		= _connectedResource->_connections.begin(); it!= _connectedResource->_connections.end(); ++it)
	{
		if(*it == this)
		{
			_connectedResource->_connections.erase(it);
			break;
		}
	}
	_connectedResource= 0;
}


template <typename SlotType>
void Resource::InputPort<SlotType>::bind(const InputPort<SlotType>& port)
{
	debug.print() << "port rebinding" << endl();
	_subResource = port._subResource;
	_type = port._type;
	// note that if the binded Resource is deleted, trying to acces
	// this port might cause a segfault
}

// ---------------------------------------------------------- OutputPort

template <typename SlotType>
Resource::OutputPort<SlotType>::OutputPort(
	Resource* myResource
	, portIndex_t myIndex
	, const string& type
	, const string& name )
:  _type(type), _name(name), _enabled(true)
{
	_metaResource.resource = myResource;
	_metaResource.index = myIndex;
	_subResource.resource = myResource;
	_subResource.index = myIndex;
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::disconnect()
{
	typename std::list<Resource::InputPort<SlotType>*>::iterator it;
	for(it = _connections.begin(); it!= _connections.end(); ++it)
	{
		(*it)->disconnect();
	}
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::bind(const OutputPort<SlotType>& port)
{
	debug.print() << "port rebinding" << endl();
	_subResource.resource = port._subResource.resource;
	_subResource.index = port._subResource.index;
	_type = port._type;
	// note that if the binded Resource is deleted, trying to acces
	// this port might cause a segfault
}



// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------



// ----------------------------------------------------------- Operators

template <typename SlotType>
bool operator >> (Resource::OutputPort<SlotType>& output, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}





}//namespace core
}//namespace kiwi
