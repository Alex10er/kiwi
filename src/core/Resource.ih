

namespace kiwi
{
namespace core
{


// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Resource -----------------------
// -----------------------------------------------------------------------------------------

using namespace std;

Resource::Resource()
{

}
	
Resource::~Resource()
{
	while(getReaderInputCount())
	{
		delete _readerInputs[_readerInputs.size()-1];
		removeReaderInputPort();
	}
	while(getReaderOutputCount())
	{
		delete _readerOutputs[_readerOutputs.size()-1];
		removeReaderOutputPort();
	}
	while(getWriterInputCount())
	{
		delete _writerInputs[_writerInputs.size()-1];
		removeWriterInputPort();
	}
	while(getWriterOutputCount())
	{
		delete _writerOutputs[_writerOutputs.size()-1];
		removeWriterOutputPort();
	}
}



template<typename ReaderType>
ReaderType* Resource::newReaderFromInput(portIndex_t index) const
{
	ScopedBlockMacro(proc_block, "Resource::newReaderFromInput()");
	assert(index < getReaderInputCount() );

	OutputPort<Reader>* p = _readerInputs[index]->connectedOutput();
	Reader* readerPtr = p->resource()->newReader( p->index() );
	if(!readerPtr)
	{
		debug.error() << "Resource::newReaderFromInput() : nil Reader pointer " << endl();
		return 0;
	};
	ReaderType* tempPtr = dynamic_cast<ReaderType*>( readerPtr );
	if(!tempPtr)
	{
		delete readerPtr;
		debug.error() << "Resource::newReaderFromInput() : uncompatible Reader types " << endl();
		return 0;
	}
	return tempPtr;
}

template<typename WriterType>
WriterType* Resource::newWriterFromInput(portIndex_t index) const
{
	ScopedBlockMacro(proc_block, "Resource::newWriterFromInput()");
	assert(index < getWriterInputCount() );
	OutputPort<Writer>* p = _writerInputs[index]->connectedOutput();
	Writer* writerPtr = p->resource()->newWriter( p->index() );
	if(!writerPtr)
	{
		debug.error() << "Resource::newWriterFromInput() : nil Writer pointer " << endl();
		return 0;
	};
	WriterType* tempPtr = dynamic_cast<WriterType*>( writerPtr );
	if(!tempPtr)
	{
		delete writerPtr;
		debug.error() << "Resource::newWriterFromInput() : uncompatible Writer types " << endl();
		return 0;
	}
	return tempPtr;
}


void Resource::addReaderInputPort(const string& name)
{
//debug.beginBlock("addReaderInputPort("+name+")");
	portIndex_t index = getReaderInputCount();
	_readerInputs.push_back( new InputPort<Reader>(this, index, name) );
//debug.endBlock();
}
void Resource::addReaderOutputPort(const string& name)
{
//debug.beginBlock("addReaderOutputPort("+name+")");
	portIndex_t index = getReaderOutputCount();
	_readerOutputs.push_back( new OutputPort<Reader>(this, index, name) );
//debug.endBlock();
}

void Resource::addWriterInputPort(const string& name)
{
//debug.beginBlock("addWriterInputPort("+name+")");
	portIndex_t index = getWriterInputCount();
	_writerInputs.push_back( new InputPort<Writer>(this, index, name) );
//debug.endBlock();
}
void Resource::addWriterOutputPort(const string& name)
{
//debug.beginBlock("addWriterOutputPort("+name+")");
	portIndex_t index = getWriterOutputCount();
	_writerOutputs.push_back( new OutputPort<Writer>(this, index, name) );
//debug.endBlock();
}


void Resource::removeReaderInputPort()
{
	_readerInputs.pop_back();
}
void Resource::removeReaderOutputPort()
{
	_readerOutputs.pop_back();
}

void Resource::removeWriterInputPort()
{
	_writerInputs.pop_back();
}
void Resource::removeWriterOutputPort()
{
	_readerOutputs.pop_back();
}

// -----------------------------------------------------------------------------------------
// -------------------------------------------------------- Port classes -------------------
// -----------------------------------------------------------------------------------------

// ----------------------------------------------------------- InputPort
template <typename SlotType>
Resource::InputPort<SlotType>::InputPort(Resource* myResource, portIndex_t myPort, const string& name)
{
	_connectedResource = 0;
	_myResource = myResource;
	_myIndex = myPort;
	_name = name;
}


template <typename SlotType>
void Resource::InputPort<SlotType>::connect(OutputPort<SlotType>& outputPort)
{
debug.beginBlock( "esource::InputPort<SlotType>::connect" );
	_connectedResource = &outputPort;
	outputPort._connections.push_back(this);
debug.endBlock();
}

template <typename SlotType>
void Resource::InputPort<SlotType>::disconnect()
{
	debug.beginBlock("Resource::InputPort<SlotType>::disconnect");
	for(typename OutputPort<SlotType>::connectionList::iterator it
		= _connectedResource->_connections.begin(); it!= _connectedResource->_connections.end(); ++it)
	{
		if(*it == this)
		{
			_connectedResource->_connections.erase(it);
			break;
		}
	}
	_connectedResource= 0;
	debug.endBlock();
}


// ---------------------------------------------------------- OutputPort

template <typename SlotType>
Resource::OutputPort<SlotType>::OutputPort(Resource* myResource, Resource::portIndex_t myPort, const string& name)
{
	_myResource = myResource;
	_myIndex = myPort;
	_name = name;
}


template <typename SlotType>
void Resource::OutputPort<SlotType>::disconnect()
{
	typename std::list<Resource::InputPort<SlotType>*>::iterator it;
	for(it = _connections.begin(); it!= _connections.end(); ++it)
	{
		it->disconnect();
	}
}


template <>
bool Resource::InputPort<Resource::Reader>::isCompatible(Resource::OutputPort<Resource::Reader>& output)
{
	Reader* theReader = output.resource()->newReader(output.index());
	bool result = _myResource->isReaderCompatible(_myIndex, theReader );
	delete theReader;
	return result;
}

template <>
bool Resource::InputPort<Resource::Writer>::isCompatible(Resource::OutputPort<Resource::Writer>& output)
{
	Writer* theWriter = output.resource()->newWriter(output.index());
	bool result = _myResource->isWriterCompatible(_myIndex, theWriter );
	delete theWriter;
	return result;
}





// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------



// ----------------------------------------------------------- Operators

template <typename SlotType>
bool operator >> (Resource::OutputPort<SlotType>& output, Resource::InputPort<SlotType>& input )
{
	if(!input.isConnected())
	{
		input.connect(output);
		return true;
	}else{return false;}
}


template <typename SlotType>
class InputPortPtrClass
{
public:
	InputPortPtrClass(Resource::InputPort<SlotType>* p) : ptr(p) {}
	Resource::InputPort<SlotType>* ptr;
};


template <typename SlotType>
class OutputPortPtrClass
{
public:
	OutputPortPtrClass(Resource::OutputPort<SlotType>* p) : ptr(p) {}
	Resource::OutputPort<SlotType>* ptr;
};





}//namespace core
}//namespace kiwi
